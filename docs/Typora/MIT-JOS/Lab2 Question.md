# Lab2 Question

3. 我们已经将内核和用户环境放置在相同的地址空间中。为什么用户程序不能读取或写入内核的内存？哪些特定机制可以保护内核内存？

>用户程序不能去随意修改内核中的代码，数据，否则可能会破坏内核，造成程序崩溃。
>
>在分页机制中，通过把页表项中的 `Supervisor/User`位置0，那么用户态的代码就不能访问内存中的这个页。

![image-20200523140406656](C:\Users\lekelei\AppData\Roaming\Typora\typora-user-images\image-20200523140406656.png)

4. 此操作系统可以支持的最大物理内存量是多少？为什么?

> 由于这个操作系统利用一个大小为4MB的空间UPAGES来存放所有的页的`PageInfo`结构体信息，每个结构体的大小为8B，所以一共可以存放512K个`PageInfo`结构体，所以一共可以出现512K个物理页，每个物理页大小为4KB，自然总的物理内存占2GB。

5. 如果我们实际拥有最大的物理内存量，那么管理内存有多少空间开销？这个开销如何分解？
5. 1- 重新访问`kern / entry.S`和 `kern / entrypgdir.c中`的页表设置。打开分页后，`EIP`仍然是一个很小的数字（略大于1MB）。在什么时候我们要过渡到在`KERNBASE`之上的`EIP`上运行？

> 在`entry.S`文件中有一个指令是`jmp *%eax`,这条指令执行后会跳转到**eax寄存器所包含的地址处**，而这个值是大于`KERNBASE`的，所以就完成了EIP从很小的数字到大于`KERNBASE`的值的转换。

6. 2- 在启用分页和开始在高于KERNBASE的EIP之间运行之后，有什么可能使我们能够以较低的EIP继续执行？为什么需要这种过渡？

> 在`entry_pgdir`这个页表中，也把虚拟地址空间[0, 4MB)映射到物理地址空间[0, 4MB)上，所以当访问位于[0, 4MB)之间的虚拟地址时，可以把它们转换为物理地址。