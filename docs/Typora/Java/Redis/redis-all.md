# redis-all

## 1.本地缓存与分布式缓存

### 本地缓存

* JDK 自带的 `HashMap` 和 `ConcurrentHashMap`
*  `Guava Cache` 、 `Spring Cache` 
*  `Caffeine` 

### 分布式缓存

* **Memcached**（很少） 和 **Redis**

使用分布式缓存会将缓存部署在一台单独的服务器上

### 本地缓存vs分布式缓存

- 本地缓存的优势是低依赖，比较轻量并且通常相比于使用分布式缓存要更加简单
- 本地缓存的局限性：
  1. **本地缓存对分布式架构支持不友好**，比如同一个相同的服务部署在多台机器上的时候，各个服务之间的缓存是无法共享的，因为本地缓存只在当前机器上有。
  1. **本地缓存容量受服务部署所在的机器限制明显。** 如果当前系统服务所耗费的内存多，那么本地缓存可用的容量就很少。

## 3.为什么要用Redis/缓存

### 高性能

操作缓存就是直接操作内存，所以速度相当快。

### 高并发

`Redis`的`QPS`远高于`MySQL`这类的数据库，所以直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，进而能够提高系统整体的并发。

>QPS（Query Per Second）：服务器每秒可以执行的查询次数；

## 4.Redis五种常见数据结构的使用场景

## 5.Redis单线程模型

由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。

关于文件事件处理器，可以阅读《Redis——事件》的笔记

## 6.设置缓存数据过期时间的作用

因为内存是有限的，所以缓存数据一直保存的话会`out of memory`

## 7.Redis如何判断数据是否过期以及过期数据的删除策略

## 8.Redis内存淘汰机制

## 9.Redis持久化机制

### 1.RDB（默认）

创建快照，将某个时间点的所有数据都存放到硬盘上。

### 2.AOF

每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入硬盘中的 AOF 文件

## 10.Redis事务

一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。

但与关系型数据库不同，Redis不支持`roll back`，因此不满足原子性

## 11.缓存穿透

大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。

### 解决方法

做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。

1）缓存无效的key值

2）布隆过滤器

**布隆过滤器：帮助判断一个给定数据是否存在于海量数据的数据结构**

通过布隆过滤器可以帮助判断用户的请求值是否合法

## 12.缓存雪崩

缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求

**可能原因：**

* 缓存模块出问题，Redis服务不可用
* 热点缓存由于过期而失效

### 解决方法

**针对 Redis 服务不可用的情况：**

1. 采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。
1. 限流，避免同时处理大量的请求。

**针对热点缓存失效的情况：**

1. 设置不同的失效时间比如随机设置缓存的失效时间。
1. 缓存永不失效。

## 13.解决 Redis 的并发竞争 Key 问题

多个系统同时对一个 key 进行操作，导致最后执行的顺序可能和我们期望的顺序不同

解决方案：分布式锁

## 14.缓存和数据库双写时的一致性问题

在更新缓存方面，对于更新完数据库后，是更新缓存？还是删除缓存？又或者是先删除缓存，再更新数据库？