## 树的子结构

### 思路

1. 首先在树A中找到和树B根结点的值一样的结点R，如果发现某一个节点的值和树B根节点值相同，则调用`isSubtreeWithRoot`进行第二部判断
2. 判断树A中以R为根节点的子树是否包含和树B一样的结构

### 收获

* 判断两个浮点数是否相等

  > 正确的比较方法是判断两个浮点数之差的绝对值是否小于一个很小的数

```java
//可以自定义一个函数Equal用于比较是否相等
boolean Equal(double num1,double num2){
    // 比较x和y是否相等，先计算其差的绝对值:
    double r = Math.abs(x - y);
    // 再判断绝对值是否足够小:
    if (r < 0.00001) {
        // 可以认为相等
        return true;
    } else {
        // 不相等
        return false;
    }
}
```

### 代码实现

1. 参考剑指offer解法

   ```java
   public class Solution {
       public static boolean HasSubtree(TreeNode root1, TreeNode root2) {
           if(root1==null||root2==null)
               return false;
           boolean result=false;
           //如果找到了对应Tree2根节点的点
           if(root1.val == root2.val)
               //以这个根节点为为起点判断是否包含Tree2
               result = isSubtreeWithRoot(root1,root2);
           
           //如果找不到，那么就再去root的左儿子当作起点，去判断是否包含Tree2
           if (!result) 
               result = HasSubtree(root1.left,root2);
           
           //如果还找不到，那么就再去root的右儿子当作起点，去判断是否包含Tree2
           if (!result) 
               result = HasSubtree(root1.right,root2);
           
           //返回结果
           return result;
       }
   
       public static boolean isSubtreeWithRoot(TreeNode node1, TreeNode node2) {
           //如果Tree2已经遍历完了都能对应的上，返回true
           if (node2 == null) 
               return true;
           //如果Tree2还没有遍历完，Tree1却遍历完了。返回false
           if (node1 == null) 
               return false;
           //如果其中有一个点没有对应上，返回false
           if (node1.val != node2.val) 
               return false;
   
           //如果根节点对应的上，那么就分别去子节点里面匹配
           return isSubtreeWithRoot(node1.left,node2.left) 
               && isSubtreeWithRoot(node1.right,node2.right);
       }
   }
   ```

2. 利用短路特性简化代码

   ```java
   public class Solution {
       public boolean HasSubtree(TreeNode root1,TreeNode root2) {
           if(root1==null||root2==null){
               return false;
           }
           return isSubtreeWithRoot(root1,root2)
               ||HasSubtree(root1.left,root2)||HasSubtree(root1.right,root2);
       }
   
       private boolean isSubtreeWithRoot(TreeNode root1,TreeNode root2){
           if(root2==null)
               return true;
           if(root1==null)
               return false;
           if(root1.val!=root2.val)
               return false;
           return isSubtreeWithRoot(root1.left,root2.left)
               &&isSubtreeWithRoot(root1.right,root2.right);
       }
   }
   ```

   